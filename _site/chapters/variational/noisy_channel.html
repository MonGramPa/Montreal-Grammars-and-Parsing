<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Noisy channel model</title>

    <link rel="stylesheet" href="/bower_components/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="/bower_components/bootstrap/dist/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="/node_modules/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="/node_modules/codemirror/theme/neat.css">
    <link rel="stylesheet" href="/assets/css/katex.min.css">
    <link rel="stylesheet" href="/assets/css/custom.css">
    <link rel="stylesheet" href="/assets/css/code.css">

    <script src="/assets/js/webchurch.min.js"></script>
    <script src="/assets/js/katex.min.js"></script>
    <script src="/bower_components/jquery/dist/jquery.min.js"></script>
    <script src="/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
    <script src="/node_modules/codemirror/lib/codemirror.js"></script>
    <script src="/node_modules/codemirror/mode/javascript/javascript.js"></script>
    <script src="/assets/js/cm-folding.js"></script>
    <script src="/assets/js/cm-comments.js"></script>
    <script src="/assets/js/webppl.min.js"></script>
    <script src="/bower_components/jquery-autosize/jquery.autosize.min.js"></script>
    <script src="/bower_components/d3/d3.min.js"></script>
    <script src="/bower_components/vega/vega.min.js"></script>
    <!-- <script src="https://probmods.org/webchurch/online/vega.min.js"></script> -->
    <script src="/bower_components/underscore/underscore.js"></script>
    <script src="/bower_components/react/JSXTransformer.js"></script>
    <script src="/bower_components/react/react-with-addons.min.js"></script>
    <script src="/bower_components/showdown/compressed/showdown.js"></script>
    <script src="/assets/js/custom.js"></script>
    <script type="text/jsx" src="/assets/js/editor.js"></script>

    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

  </head>
  <body>

    <div class="navbar navbar-default navbar-static-top" role="navigation">
      <div class="container-fluid">
        <div class="navbar-header">
          <a class="navbar-brand" href="/">Montreal Grammars and Parsing Project</a>
        </div>
        <ul class="nav navbar-nav navbar-right collapse navbar-collapse">
            <li><a href="/editor.html">Editor</a></li>
        </ul>
      </div>

    </div>

    <div class="container">

      <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<div class="page-header">
  <h1>Noisy channel model</h1>
  
</div>

<h1 id="adding-in-the-noisy-channel">Adding in the noisy channel</h1>

<h2 id="changes-to-the-generative-model">Changes to the Generative Model</h2>
<p>Recall the original generative model was:</p>

<center>
$$\begin{equation}
\begin{split}
P(X\mid Z, \Phi)P(Z\mid \Phi) = P(X\mid z', z_a, \Theta, \nu, a, b, \alpha)P(z', z_a', \Theta, \nu \mid G, a,b,\alpha)= \\
P(X\mid z', z_A, G, \nu, \Theta, a, b, \alpha) \\
\times P(z' \mid  z_a, G, \nu, \Theta, a, b, \alpha) \\
\times P(z_a \mid  G, \nu, \Theta, a,b,\alpha) \\
\times P(\nu \mid  a,b)\\
\times P(\Theta\mid \alpha) \end{split}
\end{equation}$$
</center>

<p>Since the actual ``data’’ in the joint model are bottom level PLUs, let’s change the notation a bit to accommodate an intermediate step (top-level PLUs):
Let:</p>
<ul>
  <li><script type="math/tex">TOPS</script> be the <strong>top-level PLUs</strong> produced by the adaptor grammar model (written as <script type="math/tex">X</script> above)</li>
  <li><script type="math/tex">BOTTOMS</script> be the new data being generated by the model, the <strong>bottom-level PLUs</strong>.</li>
</ul>

<p>Because most of the time, we would like identity rewrites – not a split, deletion, or substitution, we need to limit the number of those operations. We do this by drawing a random variable <script type="math/tex">\epsilon</script> from a Beta distribution parametrized by hyperparemeters <script type="math/tex">\rho_1, \rho_2</script> with a high bias towards being very small (for example, let <script type="math/tex">\rho_1 = 1</script> and <script type="math/tex">\rho_2 = 10</script>, and choose a non-identity rewrite with <script type="math/tex">P= 1-\epsilon</script>)</p>

<p>For brevity, let <script type="math/tex">\mathcal{T}</script> be the set of nonterminals which expand to bottom-layer PLUs.
We need to re-specify our latent variables and hyperparameters as well.</p>
<ul>
  <li>Let <script type="math/tex">Z</script> be our set of hidden variable collections:
    <ul>
      <li><script type="math/tex">\epsilon</script> = the Beta random variable determining the frequency of rewrites</li>
      <li><script type="math/tex">\Theta_{top} = \{\Theta_A \mid  A \in \mathcal{N}\setminus \mathcal{T}\}</script>: PCFG Multinomials for non-terminal expansions (top layer PLUs)</li>
      <li><script type="math/tex">\Theta_{bot} = \{\Theta_A \mid A \in \mathcal{T}\}</script>: PCFG multinomials for terminal expansions (bottom-layer PLUs).</li>
      <li><script type="math/tex">\nu = \{\nu_A \mid  A \in \mathcal{M}\}</script>: stick length proportions</li>
      <li><script type="math/tex">z_a = \{z_{A,i} \mid  A \in M, i \in \{1,...\} \}</script>: adapted nonterminal’s subtrees</li>
      <li><script type="math/tex">z' = \{z_A \mid  A \in \mathcal{M}\}</script>: the full tree derivations</li>
      <li>for concise notation, let <script type="math/tex">TREES = \{z_a, z'\}</script></li>
    </ul>
  </li>
  <li>For hyperparameters:
    <ul>
      <li>add parameters <script type="math/tex">\rho_1, \rho_2</script> which parametrize the Beta distribution generating <script type="math/tex">\epsilon</script></li>
      <li>add a parameter <script type="math/tex">\alpha_{bot}</script> which parameterizes the Dirichlet process generating <script type="math/tex">\Theta_{bot}</script>.</li>
      <li>add a parameter <script type="math/tex">G_{bot}</script> which is the noisy channel grammar, including rewrite, substitution, and deletion rules.</li>
      <li>similarly, let <script type="math/tex">\alpha</script> in the original model and <script type="math/tex">G</script> become <script type="math/tex">\alpha_{top}</script> and <script type="math/tex">G_{top}</script> respectively.</li>
      <li>for concise notation, let <script type="math/tex">\mathbf{G} = \{G_{top}, G_{bot}\}</script>, let <script type="math/tex">\mathbf{\alpha} = \{\alpha_{top}, \alpha_{bot}\}</script>, and let $$\rho = {\rho_1, \rho_2}</li>
    </ul>
  </li>
</ul>

<p>First, let’s rewrite our original generative model in terms of these new variables:</p>

<center>
$$\begin{equation}
\begin{split}
P(TOPS, Z, \Phi) = P(TOPS \mid Z, \Phi) P(Z \mid \Phi) = \\
P(TOPS \mid TREES, \Theta_{bot}, \Theta_{top}, \nu, a, b, \mathbf{G}, \mathbf{\alpha}) \\
\times P(TREES \mid \Theta_{bot}, \Theta_{top}, \nu, a, b, \mathbf{G}, \mathbf{\alpha}) \\
\times P(\Theta_{bot} \mid \alpha_{bot}) \\
\times P(\Theta_{top} \mid \alpha_{top}) \\
\times P(\nu \mid  a,b)
\end{split}
\end{equation}$$
</center>

<p>Now in addition, we are adding another layer to the top, namely <script type="math/tex">P(BOTTOMS \mid TOPS, Z, \Phi)</script>. If we think about what <script type="math/tex">BOTTOMS</script> depends on, we can expand this to get</p>
<center>
$$\begin{equation}
\begin{split}
P(BOTTOMS| \epsilon, TOPS, TREES,\Theta_{top},\Theta_{bot}, \nu, a, b, \mathbf{G}, \mathbf{\alpha}, \rho) \\
\times  P(\Theta_{top}|\alpha_{top})\\
\times P(TOPS \mid TREES, \Theta_{top},\Theta_{bot}, \nu, a, b,  \mathbf{G}, \mathbf{\alpha})\\
\times P(TREES, \Theta_{top}, \Theta_{bot}, \nu | a, b, \mathbf{G}, \mathbf{\alpha})
\times P(\epsilon | \rho_1, \rho_2)
\end{split}
\end{equation}
$$
</center>

<p>Thankfully, the last part is just our original generative model, so the whole model rewrites to:</p>

<center>
$$\begin{equation}
\begin{split}
P(BOTTOMS, TOPS, Z | \Phi)= P(BOTTOMS\mid TOPS, Z, \Phi)P(TOPS \mid Z, \Phi)P(Z\mid \Phi) =\\
 P(BOTTOMS \mid TOPS, TREES, \Theta_{bot}, \Theta_{top}, \nu, \Phi)P(TOPS \mid TREES, \Theta_{bot}, \Theta_{tops}, \nu, \Phi) = \\
 P(BOTTOMS \mid TOPS, TREES, \Theta_{bot}, \Theta_{top}, \nu, a, b, \mathbf{G}, \mathbf{\alpha}) \\
\times P(TOPS \mid TREES, \Theta_{bot}, \Theta_{top}, \nu, a, b, \mathbf{G}, \mathbf{\alpha}) \\
\times P(TREES \mid \Theta_{bot}, \Theta_{top}, \nu, a, b, \mathbf{G}, \mathbf{\alpha}) \\
\times P(\Theta_{bot} \mid \alpha_{bot}) \\
\times P(\Theta_{top} \mid \alpha_{top}) \\
\times P(\nu \mid  a,b)
\end{split}
\end{equation}$$
</center>

<h2 id="elbo">ELBO</h2>
<p>Recall that our ELBO before was:</p>

<center>
$$\begin{equation}\begin{split}
= \mathcal{H}(q) + \sum\limits_{A\in\mathcal{M}} \mathbb{E}_q[\log\ p(\Theta \mid  \alpha)] \\
+ \sum\limits_{A\in\mathcal{M}} \mathbb{E}_q[\log\ p(\nu \mid  a) ]\\
+ \sum\limits_{A\in\mathcal{M}} \mathbb{E}_q[\log\ p(z_A \mid  \nu, \Theta)] \\
+ \sum\limits_{A\in\mathcal{M}} \mathbb{E}_q[\log\ p(x, z' \mid  \nu_A)] \\
\end{split}\end{equation}$$
</center>

<p>We need to factor the noisy channel model into this.</p>

<center>
$$\begin{equation}\begin{split}
= \mathcal{H}(q) + \\
+ \sum\limits_{A \in \mathcal{T}} \mathbb{E}_q[\log\ p(\epsilon \mid \rho_1, \rho_2)]
+ \sum\limits_{A \in \mathcal{T}} \mathbb{E}_q[\log\ p(\Theta_{bot} \mid  \alpha_{bot}] \\
+ \sum\limits_{A\in\mathcal{M} \setminus \mathcal{T}}  \mathbb{E}_q[\log\ p(\Theta_{top} \mid  \alpha_{top}] \\
+ \sum\limits_{A\in\mathcal{M} \setminus \mathcal{T}} \mathbb{E}_q[\log\ p(\nu \mid  a, b) ]\\
+ \sum\limits_{A\in\mathcal{M}} \mathbb{E}_q[\log\ p(z_A \mid  \nu, \Theta_{bot}, \Theta_{top}, \epsilon)] \\
+ \sum\limits_{A\in\mathcal{M} \setminus \mathcal{T}} \mathbb{E}_q[\log\ p(x, z' \mid  \nu_A)] \\
\end{split}\end{equation}$$
</center>

<h2 id="updates">Updates</h2>
<p>Applying the variational methodology to this model, since we only have one added latent variable (<script type="math/tex">\Theta_{bot}</script>) we need only to find one new variational distribution. Call this distribution <script type="math/tex">q_{\tau_n}(\Theta_{bot})</script>. The update for this parameter <script type="math/tex">\tau_n</script> will be very similar to the update of the variational parameter indexed by <script type="math/tex">\Theta_{top}</script> in the original model:</p>

<center>
$$\begin{equation}
\begin{split}
\tau_{n, A\rightarrow \beta} = \sum\limits_{B\in \mathcal{T}} \sum\limits_{k=1}^{N_B} \tilde{f}(A\rightarrow \beta, S_{B,k})
\end{split}
\end{equation}$$
</center>

<p>where <script type="math/tex">\tilde{f}(A\rightarrow \beta, S_{B,k})</script> is the expected number of times the rule <script type="math/tex">A\rightarrow \beta</script> appears in the derivation <script type="math/tex">S_{B,k}</script></p>



        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'] ],
      processEscapes: true,
    }
  });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


    </div><!-- /.container -->

  </body>
</html>
