<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Notes on Stabler (2013:chps.9-10)</title>

    <link rel="stylesheet" href="/bower_components/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="/bower_components/bootstrap/dist/css/bootstrap-theme.min.css">
    <link rel="stylesheet" href="/node_modules/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="/node_modules/codemirror/theme/neat.css">
    <link rel="stylesheet" href="/assets/css/katex.min.css">
    <link rel="stylesheet" href="/assets/css/custom.css">
    <link rel="stylesheet" href="/assets/css/code.css">

    <script src="/assets/js/webchurch.min.js"></script>
    <script src="/assets/js/katex.min.js"></script>
    <script src="/bower_components/jquery/dist/jquery.min.js"></script>
    <script src="/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
    <script src="/node_modules/codemirror/lib/codemirror.js"></script>
    <script src="/node_modules/codemirror/mode/javascript/javascript.js"></script>
    <script src="/assets/js/cm-folding.js"></script>
    <script src="/assets/js/cm-comments.js"></script>
    <script src="/assets/js/webppl.min.js"></script>
    <script src="/bower_components/jquery-autosize/jquery.autosize.min.js"></script>
    <script src="/bower_components/d3/d3.min.js"></script>
    <script src="/bower_components/vega/vega.min.js"></script>
    <!-- <script src="https://probmods.org/webchurch/online/vega.min.js"></script> -->
    <script src="/bower_components/underscore/underscore.js"></script>
    <script src="/bower_components/react/JSXTransformer.js"></script>
    <script src="/bower_components/react/react-with-addons.min.js"></script>
    <script src="/bower_components/showdown/compressed/showdown.js"></script>
    <script src="/assets/js/custom.js"></script>
    <script type="text/jsx" src="/assets/js/editor.js"></script>

    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

  </head>
  <body>

    <div class="navbar navbar-default navbar-static-top" role="navigation">
      <div class="container-fluid">
        <div class="navbar-header">
          <a class="navbar-brand" href="/">Montreal Grammars and Parsing Project</a>
        </div>
        <ul class="nav navbar-nav navbar-right collapse navbar-collapse">
            <li><a href="/editor.html">Editor</a></li>
        </ul>
      </div>

    </div>

    <div class="container">

      <div class="page-header">
  <h1>Notes on Stabler (2013:chps.9-10)</h1>
</div>

<h4 id="stabler-e-2013-computational-linguistics-defining-calculating-using-and-learning-linguistic-structures-lecture-notes">Stabler, E. (2013). <em>Computational Linguistics: Defining, calculating, using, and learning linguistic structures</em>. lecture notes.</h4>

<h4 id="notes-by-chris-bruno-may-11-2017">Notes by Chris Bruno, May 11, 2017</h4>

<h1 id="mildly-context-sensitive-languages">Mildly context sensitive languages</h1>

<p>Some human languages are not context free:</p>

<ul>
  <li>Crossing dependencies in Swiss German and Dutch. <em>Respectively</em> in English</li>
  <li>Whole word reduplucation in Bambara</li>
  <li>Scrambling in some dialects of German</li>
  <li>Full phrase reduplication: English X-or-no-X, Chinese A-not-A questions</li>
</ul>

<p>Furthermore, reasonable grammars of human languages cannot be context free, in the sense that context free grammars are not able to state certain insightful generalizations, and their representations are less compact (Chomsky 1956 and others).</p>

<h1 id="minimalist-grammars">Minimalist Grammars</h1>

<p>Three types of trees:</p>

<ul>
  <li>X’ trees</li>
  <li>Bare trees</li>
  <li>Derivation trees [later]</li>
</ul>

<p>Bare trees are generated by MGs, and can be deterministically converted into X’ trees.</p>

<p><strong>Definition of a Minimalist Grammar.</strong> A minimalist grammar G is a pair (<strong>Lexicon</strong>, {<strong>merge</strong>, <strong>move</strong>})</p>

<ul>
  <li>Vocabulary <script type="math/tex">\Sigma</script> = {<code class="highlighter-rouge">every</code>, <code class="highlighter-rouge">some</code>, <code class="highlighter-rouge">student</code>, …}</li>
  <li>Types <script type="math/tex">T</script> = {<code class="highlighter-rouge">::</code>, <code class="highlighter-rouge">:</code>}</li>
  <li>Syntactic features <script type="math/tex">F</script>:
    <ul>
      <li>Selectees: <code class="highlighter-rouge">C, T, D, N, V, P, ...</code></li>
      <li>Selectors: <code class="highlighter-rouge">=C, =T, =D, =N, =V, =P, ...</code></li>
      <li>Licensors: <code class="highlighter-rouge">+wh, +case, +focus, ...</code></li>
      <li>Licensees: <code class="highlighter-rouge">-wh, -case, -focus, ...</code></li>
    </ul>
  </li>
  <li>Expressions <script type="math/tex">E</script>: trees with non-leaf nodes {&lt;, &gt;}, leaves <script type="math/tex">\Sigma* \times T \times F*</script></li>
  <li>Lexicon <strong>Lexicon</strong> <script type="math/tex">\subset \Sigma* \times \{::\} \times F*</script>, a finite set of 1-node trees</li>
</ul>

<p><strong>Notation.</strong></p>

<ul>
  <li><script type="math/tex">t[f]</script> is a tree with 1st feature <script type="math/tex">f</script> at its head, and the tree <script type="math/tex">t</script> is the result of removing <script type="math/tex">f</script> and changing <code class="highlighter-rouge">::</code> to <code class="highlighter-rouge">:</code>.</li>
  <li><script type="math/tex">t\{t_1/t_2\}</script> is the result of replacing <script type="math/tex">t_1</script> by <script type="math/tex">t_2</script> in <script type="math/tex">t</script>.</li>
  <li><script type="math/tex">t_1^></script> is the maximal projection of the head of <script type="math/tex">t_1</script>.</li>
  <li><script type="math/tex">\epsilon</script> is the 1-node tree labelled with no syntactic or phonetic features.</li>
</ul>

<p><strong>Structure building operations.</strong> Define <strong>merge</strong> and <strong>move</strong>:</p>

<p><img src="images/stabler13-chps9-10/mergemove.png" height="220" /></p>

<p><strong>Remarks.</strong></p>

<ul>
  <li>Each structure building operation checks (cancels) a pair of features.</li>
  <li>Features in a sequence are cancelled from left to right.</li>
  <li>The first selectee is merged on the right of its head (complement), and all the rest are merged to the left of its head (specifiers).</li>
  <li>All movement is overt, phrasal, and leftward.</li>
  <li>The restriction on <strong>move</strong> implements a strong version of the shortest move condition, prevents movement when there are two items competing for the same feature.</li>
</ul>

<p><strong>Example.</strong> A grammar with a transitive verb, wh-movement, and coordination. This grammar generates an infinite language.</p>

<p><img src="images/stabler13-chps9-10/mg1.png" width="450" /></p>

<p><strong>Other examples.</strong></p>

<ul>
  <li>A simplified version of Mahajan’s proposal for SOVI order in Tamil.</li>
  <li>A formalization of some of the ideas in Baker (2003).</li>
  <li>A grammar for the copy language <script type="math/tex">L_{xx} = \{xx : x \in \{a, b\}^+\}</script>.</li>
</ul>

<h1 id="simplified-mg-trees">Simplified MG trees</h1>

<p>The structure building operations only need to see:</p>

<ul>
  <li>The features of the head.</li>
  <li>Any subconstituent that has yet to move.</li>
  <li>The linear order of the strings dominated by the tree(s) (the yield/spellout)</li>
</ul>

<p>We simplify our derivation in this way:</p>

<ul>
  <li>Trees are replaced by tuples of categorized strings.</li>
  <li>Each categorized string is called a <em>chain</em>.</li>
  <li>The tuples of chains have the format <script type="math/tex">\alpha, \mu_1, \ldots, \mu_n</script> where <script type="math/tex">\alpha</script> represents the head and each <script type="math/tex">\mu_i</script> is a subconstituent that has to move.</li>
  <li>Differentiate two subcases of <strong>merge</strong>: one which merges an item which has unchecked licensee features (a mover), and one which doesn’t.</li>
</ul>

<p><strong>Example.</strong> The example derivation above, reformulated:</p>

<p><img src="images/stabler13-chps9-10/reformulated.png" height="360" /></p>

<p><strong>Reformulation of a Minimalist Grammar.</strong>
A minimalist grammar G is a pair (<strong>Lexicon</strong>, {<strong>move</strong>, <strong>merge</strong>}):</p>

<ul>
  <li>Vocabulary <script type="math/tex">\Sigma</script> = {<code class="highlighter-rouge">every</code>, <code class="highlighter-rouge">some</code>, <code class="highlighter-rouge">student</code>, …}</li>
  <li>Types <script type="math/tex">T</script> = {<code class="highlighter-rouge">::</code>, <code class="highlighter-rouge">:</code>}</li>
  <li>Syntactic features <script type="math/tex">F</script>:
    <ul>
      <li>Selectees: <code class="highlighter-rouge">C, T, D, N, V, P, ...</code></li>
      <li>Selectors: <code class="highlighter-rouge">=C, =T, =D, =N, =V, =P, ...</code></li>
      <li>Licensors: <code class="highlighter-rouge">+wh, +case, +focus, ...</code></li>
      <li>Licensees: <code class="highlighter-rouge">-wh, -case, -focus, ...</code></li>
    </ul>
  </li>
  <li>Chains <script type="math/tex">C = \Sigma* \land T \land F*</script></li>
  <li>Expressions <script type="math/tex">E = C*</script></li>
  <li>Lexicon <strong>Lexicon</strong> <script type="math/tex">\subset \Sigma* \times \{::\} \times F*</script>, a finite set of 1-node trees</li>
  <li>Structure building operations:
    <ul>
      <li>
        <p><strong>merge</strong>: <script type="math/tex">(E \times E) \to E</script> is the union of the following three functions. For any <script type="math/tex">\cdot \in \{:, ::\}, \gamma \in F*, \delta \in F^+</script> and any chains <script type="math/tex">\alpha_1, \ldots, \alpha_k, \iota_1, \ldots, \iota_l</script> (where <script type="math/tex">0 \leq k, l</script>):</p>

        <p><img src="images/stabler13-chps9-10/merge123.png" height="150" /></p>
      </li>
      <li>
        <p><strong>move</strong>: <script type="math/tex">E \to E</script> is the union of the following two functions. For any <script type="math/tex">\gamma \in F*, \delta \in F^+</script>, satisfying the following condition:</p>

        <p>(SMC) none of the chains <script type="math/tex">\alpha_1, \ldots, \alpha_{i-1}, \alpha_{i+1}, \ldots, \alpha_k</script> has <script type="math/tex">-f</script> as its first feature.</p>

        <p><img src="images/stabler13-chps9-10/move12.png" height="100" /></p>
      </li>
    </ul>
  </li>
</ul>

<p><strong>Some definitions.</strong></p>

<ul>
  <li>Structures <script type="math/tex">S(G)</script> = closure(<script type="math/tex">G</script>)</li>
  <li>Completed structures <script type="math/tex">CS(G) = \{w \cdot C \in S(G) \text{ for some } \cdot \in \{:, ::\}\}</script>, for <script type="math/tex">C</script> the start category.</li>
  <li>Sentences <script type="math/tex">L(G) = \{w : w \cdot C \in S(G), \text{ for some } \cdot \in \{:, ::\}\}</script>, the strings of category <script type="math/tex">C</script>.</li>
</ul>

<p><strong>MCFGs</strong></p>

<ul>
  <li>We can think of Context free rules, like S <script type="math/tex">\to</script> DP VP,
as an implication: if <script type="math/tex">x</script> is a DP and <script type="math/tex">y</script> is a VP then <script type="math/tex">xy</script> is an S.</li>
  <li>
    <p>So we might rewrite that rule like this:</p>

    <p>S(xy) <script type="math/tex">\leftarrow</script> DP(x) VP(y)</p>
  </li>
  <li>Terminal rules, like D <script type="math/tex">\to</script> the,
are like axioms.</li>
  <li>
    <p>So can be rewritten like this:</p>

    <p>D(the) <script type="math/tex">\leftarrow</script></p>
  </li>
  <li>
    <p>MCFGs use this kind of notation. <strong>Example.</strong> The copy language <script type="math/tex">L_{xx}</script>:</p>

    <p>S(xy) <script type="math/tex">\leftarrow</script> T(x, y)<br />
  T(<script type="math/tex">\epsilon</script>, <script type="math/tex">\epsilon</script>) <script type="math/tex">\leftarrow</script><br />
  T(xz, yw) <script type="math/tex">\leftarrow</script> A(x) A(y) T(z, w)<br />
  T(xz, yw) <script type="math/tex">\leftarrow</script> B(x) B(y) T(z, w)<br />
  A(a) <script type="math/tex">\leftarrow</script> <br />
  B(a) <script type="math/tex">\leftarrow</script></p>
  </li>
  <li>
    <p><strong>Example.</strong> Derived tree for ‘aabb’ <script type="math/tex">\in L_{xx}</script>:</p>

    <p><img src="images/stabler13-chps9-10/aabb.png" /></p>
  </li>
</ul>

<p><strong>Definition.</strong>
An MCFG is a 4-tuple <script type="math/tex">G = \langle \Sigma, N, P, S\rangle</script> with an infinite set of variables <script type="math/tex">X</script>, where:</p>

<ul>
  <li><script type="math/tex">\Sigma</script> is a finite nonempty set of vocabulary elements</li>
  <li><script type="math/tex">N</script> is a finite nonempty set of categories <script type="math/tex">A</script>, where each has dimension <script type="math/tex">dim(A) > 0</script></li>
  <li>
    <p><script type="math/tex">P</script> is a set of rules of the following form, for <script type="math/tex">n \geq 0</script>:</p>

    <script type="math/tex; mode=display">B_0(\alpha_1, \ldots, \alpha_{k_0}) \leftarrow
  B_1(x_{1,1}, \ldots, x_{1,k_1}) \ldots B_n(x_{n, 1}, \ldots, x_{n, k_n})</script>

    <p>where</p>

    <ul>
      <li>For each <script type="math/tex">0 \leq i \leq n</script>, <script type="math/tex">\dim(B_i) = k_i</script></li>
      <li>Each <script type="math/tex">x_{i,j}</script> is a variable</li>
      <li>Each <script type="math/tex">\alpha_i \in (\Sigma \cup X)*</script></li>
      <li>Each variable occurs at most once on the right, and at most once on the left.</li>
      <li>All variables on the left appear on the right</li>
    </ul>
  </li>
  <li><script type="math/tex">S \in N</script> is the start category, with <script type="math/tex">dim(S) = 1</script></li>
</ul>

<p><strong>Remark.</strong> An MCFG in which every category <script type="math/tex">A</script> has <script type="math/tex">dim(A) = 1</script> is a CFG.</p>

<p><strong>Theorem.</strong>
MCFGs and MGs are weakly equivalent. In fact, they are strongly equivalent in the sense that there is an isomorphism between the two  grammars derivations.</p>

<p><em>Example of Isomorphism.</em> The rule <strong>merge1</strong></p>

<p><img src="images/stabler13-chps9-10/merge1.png" width="650" /></p>

<p>can be translated into the following MCFG rule schema:</p>

<script type="math/tex; mode=display">\gamma, \alpha_1, \ldots, \alpha_k: (st, t_1, \ldots, t_k) \leftarrow {=f\gamma :: (s)} \quad f, \alpha_1, \ldots, \alpha_k(t, t_1, \ldots, t_k)</script>

<h1 id="derivations">Derivations</h1>

<p>We can depict the MG derivation that produces the derived trees on the right with the <strong>derivation tree</strong> on the left:</p>

<p><img src="images/stabler13-chps9-10/3trees.png" width="100%" /></p>

<p><strong>Properties.</strong></p>

<ul>
  <li>MG derivation tree languages are finite-state recognizable (i.e., we can define a regular acceptor for them) [below].</li>
  <li>A derivation tree can be transformed into a bare tree with a deterministic multi bottom-up tree transduction [see p. 120].</li>
</ul>

<h2 id="a-bottom-up-finite-state-tree-acceptor">A bottom-up finite-state tree acceptor</h2>

<p>A tree acceptor is defined by a 4-tuple <script type="math/tex">M = (\Sigma, Q, F, \delta)</script> where</p>

<ul>
  <li><script type="math/tex">\Sigma</script> is a ranked alphabet</li>
  <li><script type="math/tex">Q</script> is a set of states of rank 0 (the leaves of the tree)</li>
  <li><script type="math/tex">F \subseteq Q</script> is the set of final states</li>
  <li>
    <p><script type="math/tex">\delta</script> is a set of rules of the form</p>

    <script type="math/tex; mode=display">f(q_1, \ldots, q_n) \to q</script>

    <p>where <script type="math/tex">f \in \Sigma</script> has rank <script type="math/tex">n</script> and <script type="math/tex">q_1, \ldots, q_n, q \in Q</script></p>
  </li>
</ul>

<p>The rewrite relation <script type="math/tex">\to</script> introduces states into the trees as new leaves.
Intuitively, to accept a tree <script type="math/tex">T</script>, we proceed from the bottom up through <script type="math/tex">T</script>, replacing nodes successively as determined by the rules <script type="math/tex">\delta</script>.</p>

<p>See p. 118 for an example.</p>

<h2 id="accepting-mg-derivation-trees">Accepting MG derivation trees</h2>

<p>MG derivation trees are defined by the grammar <script type="math/tex">G = (\Sigma, F, \textbf{Lexicon}, C, \bullet, \circ)</script>
For our tree acceptor <script type="math/tex">M = (\Sigma, Q, F, \delta)</script> we let:</p>

<ul>
  <li>Ranked alphabet <script type="math/tex">\Sigma = \bullet^2, \circ^1, l^0</script> for every <script type="math/tex">l \in \textbf{Lexicon}</script></li>
  <li>States <script type="math/tex">Q = (\alpha, \mu)</script>, where <script type="math/tex">\alpha</script> is the sequence of head features and <script type="math/tex">\mu</script> is a (possibly empty) sequence of licencee features (movers).</li>
  <li>Final states <script type="math/tex">F = \{C\}</script>, the start category</li>
  <li>Rules <script type="math/tex">\delta</script> are defined by the following rule schemas. Let
    <ul>
      <li><script type="math/tex">w</script> be any sequence of vocabulary elements in the lexicon (<script type="math/tex">w \in \Sigma+</script>)</li>
      <li><script type="math/tex">\alpha, \beta</script> are nonempty sequences of features (<script type="math/tex">\alpha, \beta \in F*</script>)</li>
      <li><script type="math/tex">\mu_1, \mu_2</script> are sets of sequences of licensee features (<script type="math/tex">\mu_1, \mu_2 \in \{-f \in F\}*</script>)</li>
    </ul>
  </li>
</ul>

<p>Then our rule schemas are:</p>

<p>(lex)       <script type="math/tex">w :: \alpha() \to \alpha</script> [for each <script type="math/tex">w :: \alpha \in G</script>]<br />
   (merge1,2)  <script type="math/tex">\bullet((=x \alpha, \mu_1), (x, \mu_2)) \to (\alpha, \mu_1 \cup \mu_2)</script><br />
   (merge2)    <script type="math/tex">\bullet((=x \alpha), (\mu_1, x\beta, \mu_2)) \to (\alpha, \{\beta\} \cup \mu_1 \cup \mu_2)</script><br />
   (move1)     <script type="math/tex">\circ((+x \alpha, \mu_1 \cup \{-x\})) \to (\alpha, \mu_1)</script>  [if SMC]<br />
   (move2)     <script type="math/tex">\circ((+x \alpha, \mu_1 \cup \{-x\beta\})) \to (\alpha, \mu_1 \cup \{\beta\})</script> [if SMC]</p>

<p><strong>Intuition.</strong></p>

<ul>
  <li>(lex) replaces each leaf with its syntactic features</li>
  <li>The other rules carry out the structure building operations, replacing each intermediate node with a tuple of sequences of features representing the unchecked features left over</li>
  <li>The tree is accepted once we reach the top node, and rewrite it as just \texttt{C}.</li>
</ul>

<p><strong>Example.</strong>
We want to accept this derivation tree:</p>

<p><img src="images/stabler13-chps9-10/dtree1.png" height="160" /></p>

<p>Apply rule (lex):</p>

<p><img src="images/stabler13-chps9-10/lex.png" height="180" /></p>

<p>Apply the other rules bottom-up:</p>

<p><img src="images/stabler13-chps9-10/steps1-5.png" height="200" /></p>



    </div><!-- /.container -->

  </body>
</html>
